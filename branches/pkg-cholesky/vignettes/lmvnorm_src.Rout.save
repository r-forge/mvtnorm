
> library("mvtnorm")

> chk <- function(...) stopifnot(isTRUE(all.equal(...)))

> set.seed(290875)

> N <- 4

> J <- 5

> rn <- paste0("C_", 1:N)

> nm <- LETTERS[1:J]

> Jn <- J * (J - 1)/2

> xn <- matrix(runif(N * Jn), nrow = N, byrow = TRUE)

> rownames(xn) <- rn

> xd <- matrix(runif(N * (Jn + J)), nrow = N, byrow = TRUE)

> rownames(xd) <- rn

> (lxn <- ltMatrices(xn, byrow = TRUE, names = nm))
, , C_1

           A         B          C         D E
A 1.00000000 0.0000000 0.00000000 0.0000000 0
B 0.51236601 1.0000000 0.00000000 0.0000000 0
C 0.05847253 0.9095137 1.00000000 0.0000000 0
D 0.39448719 0.6612143 0.23352591 1.0000000 0
E 0.51647518 0.2979867 0.07517749 0.8182123 1

, , C_2

          A         B         C        D E
A 1.0000000 0.0000000 0.0000000 0.000000 0
B 0.8590665 1.0000000 0.0000000 0.000000 0
C 0.3744315 0.1022684 1.0000000 0.000000 0
D 0.1165248 0.7956529 0.8930589 1.000000 0
E 0.1948049 0.4730419 0.2377852 0.214606 1

, , C_3

          A         B         C         D E
A 1.0000000 0.0000000 0.0000000 0.0000000 0
B 0.4530153 1.0000000 0.0000000 0.0000000 0
C 0.9045608 0.9269936 1.0000000 0.0000000 0
D 0.4490011 0.1326375 0.4153967 1.0000000 0
E 0.9574833 0.4917481 0.7160702 0.2938002 1

, , C_4

             A         B           C         D E
A 1.0000000000 0.0000000 0.000000000 0.0000000 0
B 0.4877241328 1.0000000 0.000000000 0.0000000 0
C 0.0593045885 0.7625270 1.000000000 0.0000000 0
D 0.0005227393 0.1995700 0.470508903 1.0000000 0
E 0.4913541358 0.2849431 0.005961103 0.8901458 1


> dim(lxn)
[1] 4 5 5

> dimnames(lxn)
[[1]]
[1] "C_1" "C_2" "C_3" "C_4"

[[2]]
[1] "A" "B" "C" "D" "E"

[[3]]
[1] "A" "B" "C" "D" "E"


> lxd <- ltMatrices(xd, byrow = TRUE, diag = TRUE, names = nm)

> dim(lxd)
[1] 4 5 5

> dimnames(lxd)
[[1]]
[1] "C_1" "C_2" "C_3" "C_4"

[[2]]
[1] "A" "B" "C" "D" "E"

[[3]]
[1] "A" "B" "C" "D" "E"


> class(lxn) <- "syMatrices"

> lxn
, , C_1

           A         B          C         D          E
A 1.00000000 0.5123660 0.05847253 0.3944872 0.51647518
B 0.51236601 1.0000000 0.90951367 0.6612143 0.29798667
C 0.05847253 0.9095137 1.00000000 0.2335259 0.07517749
D 0.39448719 0.6612143 0.23352591 1.0000000 0.81821229
E 0.51647518 0.2979867 0.07517749 0.8182123 1.00000000

, , C_2

          A         B         C         D         E
A 1.0000000 0.8590665 0.3744315 0.1165248 0.1948049
B 0.8590665 1.0000000 0.1022684 0.7956529 0.4730419
C 0.3744315 0.1022684 1.0000000 0.8930589 0.2377852
D 0.1165248 0.7956529 0.8930589 1.0000000 0.2146060
E 0.1948049 0.4730419 0.2377852 0.2146060 1.0000000

, , C_3

          A         B         C         D         E
A 1.0000000 0.4530153 0.9045608 0.4490011 0.9574833
B 0.4530153 1.0000000 0.9269936 0.1326375 0.4917481
C 0.9045608 0.9269936 1.0000000 0.4153967 0.7160702
D 0.4490011 0.1326375 0.4153967 1.0000000 0.2938002
E 0.9574833 0.4917481 0.7160702 0.2938002 1.0000000

, , C_4

             A         B           C            D           E
A 1.0000000000 0.4877241 0.059304588 0.0005227393 0.491354136
B 0.4877241328 1.0000000 0.762527028 0.1995699527 0.284943077
C 0.0593045885 0.7625270 1.000000000 0.4705089033 0.005961103
D 0.0005227393 0.1995700 0.470508903 1.0000000000 0.890145786
E 0.4913541358 0.2849431 0.005961103 0.8901457863 1.000000000


> a <- as.array(ltMatrices(xn, byrow = TRUE))

> b <- as.array(ltMatrices(ltMatrices(xn, byrow = TRUE), 
+     byrow = FALSE))

> chk(a, b)

> a <- as.array(ltMatrices(xn, byrow = FALSE))

> b <- as.array(ltMatrices(ltMatrices(xn, byrow = FALSE), 
+     byrow = TRUE))

> chk(a, b)

> a <- as.array(ltMatrices(xd, byrow = TRUE, diag = TRUE))

> b <- as.array(ltMatrices(ltMatrices(xd, byrow = TRUE, 
+     diag = TRUE), byrow = FALSE))

> chk(a, b)

> a <- as.array(ltMatrices(xd, byrow = FALSE, diag = TRUE))

> b <- as.array(ltMatrices(ltMatrices(xd, byrow = FALSE, 
+     diag = TRUE), byrow = TRUE))

> chk(a, b)

> a <- as.array(ltMatrices(t(xn), trans = TRUE))

> b <- as.array(ltMatrices(ltMatrices(t(xn), trans = TRUE), 
+     trans = FALSE))

> chk(a, b)

> a <- as.array(ltMatrices(xn, trans = FALSE))

> b <- as.array(ltMatrices(ltMatrices(xn, trans = FALSE), 
+     trans = TRUE))

> chk(a, b)

> a <- as.array(ltMatrices(t(xd), trans = TRUE, diag = TRUE))

> b <- as.array(ltMatrices(ltMatrices(t(xd), trans = TRUE, 
+     diag = TRUE), trans = FALSE))

> chk(a, b)

> a <- as.array(ltMatrices(xd, trans = FALSE, diag = TRUE))

> b <- as.array(ltMatrices(ltMatrices(xd, trans = FALSE, 
+     diag = TRUE), trans = TRUE))

> chk(a, b)

> a <- as.array(ltMatrices(xn, byrow = FALSE)[1:2, 2:4])

> b <- as.array(ltMatrices(xn, byrow = FALSE))[2:4, 
+     2:4, 1:2]

> chk(a, b)

> a <- as.array(ltMatrices(xn, byrow = TRUE)[1:2, 2:4])

> b <- as.array(ltMatrices(xn, byrow = TRUE))[2:4, 2:4, 
+     1:2]

> chk(a, b)

> a <- as.array(ltMatrices(xd, byrow = FALSE, diag = TRUE)[1:2, 
+     2:4])

> b <- as.array(ltMatrices(xd, byrow = FALSE, diag = TRUE))[2:4, 
+     2:4, 1:2]

> chk(a, b)

> a <- as.array(ltMatrices(xd, byrow = TRUE, diag = TRUE)[1:2, 
+     2:4])

> b <- as.array(ltMatrices(xd, byrow = TRUE, diag = TRUE))[2:4, 
+     2:4, 1:2]

> chk(a, b)

> a <- as.array(ltMatrices(t(xn), byrow = FALSE, trans = TRUE)[1:2, 
+     2:4])

> b <- as.array(ltMatrices(t(xn), byrow = FALSE, trans = TRUE))[2:4, 
+     2:4, 1:2]

> chk(a, b)

> a <- as.array(ltMatrices(t(xn), byrow = TRUE, trans = TRUE)[1:2, 
+     2:4])

> b <- as.array(ltMatrices(t(xn), byrow = TRUE, trans = TRUE))[2:4, 
+     2:4, 1:2]

> chk(a, b)

> a <- as.array(ltMatrices(t(xd), byrow = FALSE, diag = TRUE, 
+     trans = TRUE)[1:2, 2:4])

> b <- as.array(ltMatrices(t(xd), byrow = FALSE, diag = TRUE, 
+     trans = TRUE))[2:4, 2:4, 1:2]

> chk(a, b)

> a <- as.array(ltMatrices(t(xd), byrow = TRUE, diag = TRUE, 
+     trans = TRUE)[1:2, 2:4])

> b <- as.array(ltMatrices(t(xd), byrow = TRUE, diag = TRUE, 
+     trans = TRUE))[2:4, 2:4, 1:2]

> chk(a, b)

> all(diagonals(ltMatrices(xn, byrow = TRUE)) == 1)
[1] TRUE

> lxn <- ltMatrices(xn, byrow = TRUE)

> lxd <- ltMatrices(xd, byrow = TRUE, diag = TRUE)

> y <- matrix(runif(N * J), nrow = J)

> a <- Mult(lxn, y)

> A <- as.array(lxn)

> b <- do.call("rbind", lapply(1:ncol(y), function(i) t(A[, 
+     , i] %*% y[, i, drop = FALSE])))

> chk(a, t(b), check.attributes = FALSE)

> a <- Mult(lxd, y)

> A <- as.array(lxd)

> b <- do.call("rbind", lapply(1:ncol(y), function(i) t(A[, 
+     , i] %*% y[, i, drop = FALSE])))

> chk(a, t(b), check.attributes = FALSE)

> chk(Mult(lxn[rep(1, N), ], y), Mult(lxn[1, ], y), 
+     check.attributes = FALSE)

> chk(Mult(lxn, y[, 1]), Mult(lxn, y[, rep(1, N)]))

> i <- sample(1:N)[1]

> M <- t(as.array(lxn)[, , i])

> a <- sapply(1:J, function(j) Mult(lxn[i, ], M[, j, 
+     drop = FALSE]))

> rownames(a) <- colnames(a) <- dimnames(lxn)[[2]]

> b <- as.array(Tcrossprod(lxn[i, ]))[, , 1]

> chk(a, b, check.attributes = FALSE)

> A <- as.array(lxn)

> a <- solve(lxn)

> a <- as.array(a)

> b <- array(apply(A, 3, function(x) solve(x), simplify = TRUE), 
+     dim = rev(dim(lxn)))

> chk(a, b, check.attributes = FALSE)

> A <- as.array(lxd)

> a <- as.array(solve(lxd))

> b <- array(apply(A, 3, function(x) solve(x), simplify = TRUE), 
+     dim = rev(dim(lxd)))

> chk(a, b, check.attributes = FALSE)

> chk(solve(lxn, y), Mult(solve(lxn), y))

> chk(solve(lxd, y), Mult(solve(lxd), y))

> chk(solve(lxn[1, ], y), as.array(solve(lxn[1, ]))[, 
+     , 1] %*% y)

> chk(solve(lxn[rep(1, N), ], y), solve(lxn[1, ], y), 
+     check.attributes = FALSE)

> chk(solve(lxn, y[, 1]), solve(lxn, y[, rep(1, N)]))

> a <- as.array(Tcrossprod(lxn))

> b <- array(apply(as.array(lxn), 3, function(x) tcrossprod(x), 
+     simplify = TRUE), dim = rev(dim(lxn)))

> chk(a, b, check.attributes = FALSE)

> d <- Tcrossprod(lxn, diag_only = TRUE)

> chk(d, apply(a, 3, diag))

> chk(d, diagonals(Tcrossprod(lxn)))

> a <- as.array(Tcrossprod(lxd))

> b <- array(apply(as.array(lxd), 3, function(x) tcrossprod(x), 
+     simplify = TRUE), dim = rev(dim(lxd)))

> chk(a, b, check.attributes = FALSE)

> d <- Tcrossprod(lxd, diag_only = TRUE)

> chk(d, apply(a, 3, diag))

> chk(d, diagonals(Tcrossprod(lxd)))

> a <- as.array(Crossprod(lxn))

> b <- array(apply(as.array(lxn), 3, function(x) crossprod(x), 
+     simplify = TRUE), dim = rev(dim(lxn)))

> chk(a, b, check.attributes = FALSE)

> d <- Crossprod(lxn, diag_only = TRUE)

> chk(d, apply(a, 3, diag))

> chk(d, diagonals(Crossprod(lxn)))

> a <- as.array(Crossprod(lxd))

> b <- array(apply(as.array(lxd), 3, function(x) crossprod(x), 
+     simplify = TRUE), dim = rev(dim(lxd)))

> chk(a, b, check.attributes = FALSE)

> d <- Crossprod(lxd, diag_only = TRUE)

> chk(d, apply(a, 3, diag))

> chk(d, diagonals(Crossprod(lxd)))

> Sigma <- Tcrossprod(lxd)

> chk(chol(Sigma), lxd)

> Sigma <- Tcrossprod(lxn)

> chk(as.array(chol(Sigma)), as.array(lxn))

> chk(as.array(adddiag(lxn)), as.array(lxn))

> chk(as.array(adddiag(lxd)), as.array(lxd))

> Sigma <- apply(as.array(lxn), 3, function(x) tcrossprod(solve(x)), 
+     simplify = FALSE)

> Prec <- lapply(Sigma, solve)

> Corr <- lapply(Sigma, cov2cor)

> CP <- lapply(Corr, solve)

> chk(unlist(Sigma), c(as.array(invchol2cov(lxn))), 
+     check.attributes = FALSE)

> chk(unlist(Prec), c(as.array(invchol2pre(lxn))), check.attributes = FALSE)

> chk(unlist(Corr), c(as.array(invchol2cor(lxn))), check.attributes = FALSE)

> chk(unlist(CP), c(as.array(Crossprod(invcholD(lxn)))), 
+     check.attributes = FALSE)

> Sigma <- apply(as.array(lxn), 3, function(x) tcrossprod(x), 
+     simplify = FALSE)

> Prec <- lapply(Sigma, solve)

> Corr <- lapply(Sigma, cov2cor)

> CP <- lapply(Corr, solve)

> chk(unlist(Sigma), c(as.array(chol2cov(lxn))), check.attributes = FALSE)

> chk(unlist(Prec), c(as.array(chol2pre(lxn))), check.attributes = FALSE)

> chk(unlist(Corr), c(as.array(chol2cor(lxn))), check.attributes = FALSE)

> chk(unlist(CP), c(as.array(Crossprod(solve(D1chol(lxn))))), 
+     check.attributes = FALSE)

> Sigma <- apply(as.array(lxd), 3, function(x) tcrossprod(solve(x)), 
+     simplify = FALSE)

> Prec <- lapply(Sigma, solve)

> Corr <- lapply(Sigma, cov2cor)

> CP <- lapply(Corr, solve)

> chk(unlist(Sigma), c(as.array(invchol2cov(lxd))), 
+     check.attributes = FALSE)

> chk(unlist(Prec), c(as.array(invchol2pre(lxd))), check.attributes = FALSE)

> chk(unlist(Corr), c(as.array(invchol2cor(lxd))), check.attributes = FALSE)

> chk(unlist(CP), c(as.array(Crossprod(invcholD(lxd)))), 
+     check.attributes = FALSE)

> Sigma <- apply(as.array(lxd), 3, function(x) tcrossprod(x), 
+     simplify = FALSE)

> Prec <- lapply(Sigma, solve)

> Corr <- lapply(Sigma, cov2cor)

> CP <- lapply(Corr, solve)

> chk(unlist(Sigma), c(as.array(chol2cov(lxd))), check.attributes = FALSE)

> chk(unlist(Prec), c(as.array(chol2pre(lxd))), check.attributes = FALSE)

> chk(unlist(Corr), c(as.array(chol2cor(lxd))), check.attributes = FALSE)

> chk(unlist(CP), c(as.array(Crossprod(solve(D1chol(lxd))))), 
+     check.attributes = FALSE)

> Sigma <- Tcrossprod(lxd)

> j <- 1:3

> chk(Sigma[, j], Tcrossprod(marg_mvnorm(chol = lxd, 
+     which = j)$chol))

> j <- 2:4

> chk(Sigma[, j], Tcrossprod(marg_mvnorm(chol = lxd, 
+     which = j)$chol))

> Sigma <- Tcrossprod(solve(lxd))

> j <- 1:3

> chk(Sigma[, j], Tcrossprod(solve(marg_mvnorm(invchol = lxd, 
+     which = j)$invchol)))

> j <- 2:4

> chk(Sigma[, j], Tcrossprod(solve(marg_mvnorm(invchol = lxd, 
+     which = j)$invchol)))

> Sigma <- as.array(Tcrossprod(lxd))[, , 1]

> j <- 2:4

> y <- matrix(c(-1, 2, 1), nrow = 3)

> cm <- Sigma[-j, j, drop = FALSE] %*% solve(Sigma[j, 
+     j]) %*% y

> cS <- Sigma[-j, -j] - Sigma[-j, j, drop = FALSE] %*% 
+     solve(Sigma[j, j]) %*% Sigma[j, -j, drop = FALSE]

> cmv <- cond_mvnorm(chol = lxd[1, ], which = j, given = y)

> chk(cm, cmv$mean)

> chk(cS, as.array(Tcrossprod(cmv$chol))[, , 1])

> Sigma <- as.array(Tcrossprod(solve(lxd)))[, , 1]

> j <- 2:4

> y <- matrix(c(-1, 2, 1), nrow = 3)

> cm <- Sigma[-j, j, drop = FALSE] %*% solve(Sigma[j, 
+     j]) %*% y

> cS <- Sigma[-j, -j] - Sigma[-j, j, drop = FALSE] %*% 
+     solve(Sigma[j, j]) %*% Sigma[j, -j, drop = FALSE]

> cmv <- cond_mvnorm(invchol = lxd[1, ], which = j, 
+     given = y)

> chk(cm, cmv$mean)

> chk(cS, as.array(Tcrossprod(solve(cmv$invchol)))[, 
+     , 1])

> Sigma <- as.array(Tcrossprod(lxd))[, , 1]

> j <- 1:3

> y <- matrix(c(-1, 2, 1), nrow = 3)

> cm <- Sigma[-j, j, drop = FALSE] %*% solve(Sigma[j, 
+     j]) %*% y

> cS <- Sigma[-j, -j] - Sigma[-j, j, drop = FALSE] %*% 
+     solve(Sigma[j, j]) %*% Sigma[j, -j, drop = FALSE]

> cmv <- cond_mvnorm(chol = lxd[1, ], which = j, given = y)

> chk(c(cm), c(cmv$mean))

> chk(cS, as.array(Tcrossprod(cmv$chol))[, , 1])

> Sigma <- as.array(Tcrossprod(solve(lxd)))[, , 1]

> j <- 1:3

> y <- matrix(c(-1, 2, 1), nrow = 3)

> cm <- Sigma[-j, j, drop = FALSE] %*% solve(Sigma[j, 
+     j]) %*% y

> cS <- Sigma[-j, -j] - Sigma[-j, j, drop = FALSE] %*% 
+     solve(Sigma[j, j]) %*% Sigma[j, -j, drop = FALSE]

> cmv <- cond_mvnorm(invchol = lxd[1, ], which = j, 
+     given = y)

> chk(c(cm), c(cmv$mean))

> chk(cS, as.array(Tcrossprod(solve(cmv$invchol)))[, 
+     , 1])

> N <- 1000

> J <- 50

> lt <- ltMatrices(matrix(runif(N * J * (J + 1)/2) + 
+     1, ncol = N), diag = TRUE, byrow = FALSE, trans = TRUE)

> Z <- matrix(rnorm(N * J), ncol = N)

> Y <- solve(lt, Z)

> ll1 <- sum(dnorm(Mult(lt, Y), log = TRUE)) + sum(log(diagonals(lt)))

> S <- as.array(Tcrossprod(solve(lt)))

> ll2 <- sum(sapply(1:N, function(i) dmvnorm(x = Y[, 
+     i], sigma = S[, , i], log = TRUE)))

> chk(ll1, ll2)

> (j <- 1:5 * 10)
[1] 10 20 30 40 50

> md <- marg_mvnorm(invchol = lt, which = j)

> cd <- cond_mvnorm(invchol = lt, which = j, given = Y[j, 
+     ])

> ll3 <- sum(dnorm(Mult(md$invchol, Y[j, ]), log = TRUE)) + 
+     sum(log(diagonals(md$invchol))) + sum(dnorm(Mult(cd$invchol, 
+     Y[-j, ] - cd$me .... [TRUNCATED] 

> chk(ll1, ll3)

> library("mvtnorm")

> lmvnormR <- function(lower, upper, mean = 0, chol, 
+     logLik = TRUE, ...) {
+     if (!is.matrix(lower)) 
+         lower <- matrix(lower, ncol  .... [TRUNCATED] 

> J <- 5

> N <- 10

> x <- matrix(runif(N * J * (J + 1)/2), ncol = N)

> lx <- ltMatrices(x, byrow = TRUE, trans = TRUE, diag = TRUE)

> a <- matrix(runif(N * J), nrow = J) - 2

> a[sample(J * N)[1:2]] <- -Inf

> b <- a + 2 + matrix(runif(N * J), nrow = J)

> b[sample(J * N)[1:2]] <- Inf

> (phat <- c(lmvnormR(a, b, chol = lx, logLik = FALSE)))
 [1] 0.0000000 0.4162879 0.3521673 0.5471083 0.4547582 0.3340351 0.3177301
 [8] 0.4333427 0.0000000 0.6454150

> phat
 [1] 0.0000000 0.4162879 0.3521673 0.5471083 0.4547582 0.3340351 0.3177301
 [8] 0.4333427 0.0000000 0.6454150

> exp(lmvnorm(a, b, chol = lx, M = 25000, logLik = FALSE, 
+     fast = TRUE))
 [1] 8.881784e-21 4.165599e-01 3.517157e-01 5.484527e-01 4.579683e-01
 [6] 3.338785e-01 3.175085e-01 4.320235e-01 8.881784e-21 6.446996e-01

> exp(lmvnorm(a, b, chol = lx, M = 25000, logLik = FALSE, 
+     fast = FALSE))
 [1] 8.881784e-21 4.148293e-01 3.523091e-01 5.470658e-01 4.569658e-01
 [6] 3.363092e-01 3.181112e-01 4.336720e-01 8.881784e-21 6.454407e-01

> M <- 10000

> if (require("qrng")) {
+     W <- t(ghalton(M * N, d = J - 1))
+ } else {
+     W <- matrix(runif(M * N * (J - 1)), ncol = M)
+ }
Loading required package: qrng

> pGB <- lmvnormR(a, b, chol = lx, logLik = FALSE, algorithm = GenzBretz(maxpts = M, 
+     abseps = 0, releps = 0))

> pGqf <- exp(lmvnorm(a, b, chol = lx, w = W, M = M, 
+     logLik = FALSE, fast = TRUE))

> pGf <- exp(lmvnorm(a, b, chol = lx, w = NULL, M = M, 
+     logLik = FALSE, fast = TRUE))

> pGqs <- exp(lmvnorm(a, b, chol = lx, w = W, M = M, 
+     logLik = FALSE, fast = FALSE))

> pGs <- exp(lmvnorm(a, b, chol = lx, w = NULL, M = M, 
+     logLik = FALSE, fast = FALSE))

> cbind(pGB, pGqf, pGf, pGqs, pGs)
            pGB         pGqf          pGf         pGqs          pGs
 [1,] 0.0000000 2.220446e-20 2.220446e-20 2.220446e-20 2.220446e-20
 [2,] 0.4167053 4.161690e-01 4.162052e-01 4.161704e-01 4.152929e-01
 [3,] 0.3521572 3.521519e-01 3.524463e-01 3.521535e-01 3.529928e-01
 [4,] 0.5471531 5.471200e-01 5.429125e-01 5.471207e-01 5.459049e-01
 [5,] 0.4547521 4.555023e-01 4.538366e-01 4.555029e-01 4.550493e-01
 [6,] 0.3340352 3.341323e-01 3.362067e-01 3.341317e-01 3.297836e-01
 [7,] 0.3179135 3.179560e-01 3.202915e-01 3.179562e-01 3.192830e-01
 [8,] 0.4336671 4.337769e-01 4.373165e-01 4.337770e-01 4.312718e-01
 [9,] 0.0000000 2.220446e-20 2.220446e-20 2.220446e-20 2.220446e-20
[10,] 0.6459174 6.457455e-01 6.455624e-01 6.457457e-01 6.526470e-01

> pGB <- lmvnormR(a[1, , drop = FALSE], b[1, , drop = FALSE], 
+     chol = lx[, 1], logLik = FALSE, algorithm = GenzBretz(maxpts = M, 
+         abse .... [TRUNCATED] 

> pGq <- exp(lmvnorm(a[1, , drop = FALSE], b[1, , drop = FALSE], 
+     chol = lx[, 1], logLik = FALSE))

> ptr <- pnorm(b[1, ]/c(unclass(lx[, 1]))) - pnorm(a[1, 
+     ]/c(unclass(lx[, 1])))

> cbind(c(ptr), pGB, pGq)
                      pGB       pGq
 [1,] 0.9810344 0.9810344 0.9810344
 [2,] 0.9459425 0.9459425 0.9459425
 [3,] 0.9060151 0.9060151 0.9060151
 [4,] 0.9993789 0.9993789 0.9993789
 [5,] 0.9957268 0.9957268 0.9957268
 [6,] 1.0000000 1.0000000 1.0000000
 [7,] 1.0000000 1.0000000 1.0000000
 [8,] 0.9995482 0.9995482 0.9995482
 [9,] 0.9616381 0.9616381 0.9616381
[10,] 0.9981752 0.9981752 0.9981752

> J <- 10

> d <- TRUE

> L <- diag(J)

> L[lower.tri(L, diag = d)] <- prm <- runif(J * (J + 
+     c(-1, 1)[d + 1])/2)

> C <- solve(L)

> D <- -kronecker(t(C), C)

> S <- diag(J)

> S[lower.tri(S, diag = TRUE)] <- x <- runif(J * (J + 
+     1)/2)

> SD0 <- matrix(c(S) %*% D, ncol = J)

> SD1 <- -crossprod(C, tcrossprod(S, C))

> a <- ltMatrices(C[lower.tri(C, diag = TRUE)], diag = TRUE, 
+     byrow = FALSE, trans = TRUE)

> b <- ltMatrices(x, diag = TRUE, byrow = FALSE, trans = TRUE)

> SD2 <- -mvtnorm:::.gradSolveL(a, b, diag = d)

> chk(SD0[lower.tri(SD0, diag = d)], SD1[lower.tri(SD1, 
+     diag = d)])

> chk(SD0[lower.tri(SD0, diag = d)], c(unclass(SD2)))

> J <- 5

> N <- 4

> S <- crossprod(matrix(runif(J^2), nrow = J))

> prm <- t(chol(S))[lower.tri(S, diag = TRUE)]

> mC <- ltMatrices(matrix(prm, ncol = 1), trans = TRUE, 
+     diag = TRUE)

> a <- matrix(runif(N * J), nrow = J) - 2

> b <- a + 4

> a[2, ] <- -Inf

> b[3, ] <- Inf

> M <- 10000

> W <- matrix(runif(M * (J - 1)), ncol = M)

> lli <- c(lmvnorm(a, b, chol = mC, w = W, M = M, logLik = FALSE))

> fC <- function(prm) {
+     C <- ltMatrices(matrix(prm, ncol = 1), trans = TRUE, diag = TRUE)
+     lmvnorm(a, b, chol = C, w = W, M = M)
+ }

> sC <- smvnorm(a, b, chol = mC, w = W, M = M)

> chk(lli, sC$logLik)

> if (require("numDeriv")) print(max(abs(grad(fC, unclass(mC)) - 
+     rowSums(unclass(sC$chol)))))
Loading required package: numDeriv
[1] 5.360648e-09

> mL <- solve(mC)

> lliL <- c(lmvnorm(a, b, invchol = mL, w = W, M = M, 
+     logLik = FALSE))

> chk(lli, lliL)

> fL <- function(prm) {
+     L <- ltMatrices(matrix(prm, ncol = 1), trans = TRUE, diag = TRUE)
+     lmvnorm(a, b, invchol = L, w = W, M = M)
+ }

> sL <- smvnorm(a, b, invchol = mL, w = W, M = M)

> chk(lliL, sL$logLik)

> if (require("numDeriv")) print(max(abs(grad(fL, unclass(mL)) - 
+     rowSums(unclass(sL$chol)))))
[1] 2.575826e-09

> ptr <- pnorm(b[1, ]/c(unclass(mC[, 1]))) - pnorm(a[1, 
+     ]/c(unclass(mC[, 1])))

> log(ptr)
[1] -0.1851247 -0.1902665 -0.1614033 -0.1017233

> lmvnorm(a[1, , drop = FALSE], b[1, , drop = FALSE], 
+     chol = mC[, 1], logLik = FALSE)
[1] -0.1851247 -0.1902665 -0.1614033 -0.1017233

> lapply(smvnorm(a[1, , drop = FALSE], b[1, , drop = FALSE], 
+     chol = mC[, 1], logLik = TRUE), unclass)
$logLik
[1] -0.1851247 -0.1902665 -0.1614033 -0.1017233

$mean
     [,1] [,2] [,3] [,4]
[1,]    0    0    0    0

$chol
          [,1]       [,2]       [,3]      [,4]
1.1 -0.3023276 -0.3016162 -0.3046262 -0.302357
attr(,"J")
[1] 1
attr(,"diag")
[1] TRUE
attr(,"byrow")
[1] FALSE
attr(,"trans")
[1] TRUE
attr(,"rcnames")
[1] "1"


> sd1 <- c(unclass(mC[, 1]))

> (dnorm(b[1, ]/sd1) * b[1, ] - dnorm(a[1, ]/sd1) * 
+     a[1, ]) * (-1)/sd1^2/ptr
[1] -0.3023276 -0.3016162 -0.3046262 -0.3023570

> J <- 4

> R <- diag(J)

> R[1, 2] <- R[2, 1] <- 0.25

> R[1, 3] <- R[3, 1] <- 0.5

> R[2, 4] <- R[4, 2] <- 0.75

> (Sigma <- diag(sqrt(1:J/2)) %*% R %*% diag(sqrt(1:J/2)))
          [,1]      [,2]      [,3]    [,4]
[1,] 0.5000000 0.1767767 0.4330127 0.00000
[2,] 0.1767767 1.0000000 0.0000000 1.06066
[3,] 0.4330127 0.0000000 1.5000000 0.00000
[4,] 0.0000000 1.0606602 0.0000000 2.00000

> (C <- t(chol(Sigma)))
          [,1]       [,2]      [,3]      [,4]
[1,] 0.7071068  0.0000000 0.0000000 0.0000000
[2,] 0.2500000  0.9682458 0.0000000 0.0000000
[3,] 0.6123724 -0.1581139 1.0488088 0.0000000
[4,] 0.0000000  1.0954451 0.1651446 0.8790491

> prm <- C[lower.tri(C, diag = TRUE)]

> lt <- ltMatrices(matrix(prm, ncol = 1), diag = TRUE, 
+     byrow = FALSE, trans = TRUE)

> BYROW <- FALSE

> lt <- ltMatrices(lt, byrow = BYROW, trans = TRUE)

> chk(C, as.array(lt)[, , 1], check.attributes = FALSE)

> chk(Sigma, as.array(Tcrossprod(lt))[, , 1], check.attributes = FALSE)

> N <- 100

> Z <- matrix(rnorm(N * J), nrow = J)

> Y <- Mult(lt, Z) + (mn <- 1:J)

> prb <- 1:9/10

> sds <- sqrt(diag(Sigma))

> ct <- sapply(1:J, function(j) qnorm(prb, mean = mn[j], 
+     sd = sds[j]))

> lwr <- upr <- Y

> for (j in 1:J) {
+     f <- cut(Y[j, ], breaks = c(-Inf, ct[, j], Inf))
+     lwr[j, ] <- c(-Inf, ct[, j])[f]
+     upr[j, ] <- c(ct[, j], Inf)[f]
+ .... [TRUNCATED] 

> rowMeans(Y)
       1        2        3        4 
1.001581 1.930707 2.949487 3.809772 

> (Shat <- var(t(Y)))
            1           2           3           4
1  0.49613028  0.13904203  0.44517502 -0.08930947
2  0.13904203  1.05349524 -0.07451484  1.12902099
3  0.44517502 -0.07451484  1.54572038 -0.06188290
4 -0.08930947  1.12902099 -0.06188290  2.15211344

> M <- floor(exp(0:25/10) * 1000)

> lGB <- sapply(M, function(m) {
+     st <- system.time(ret <- lmvnormR(lwr, upr, mean = mn, chol = lt, 
+         algorithm = GenzBretz(maxpts = m,  .... [TRUNCATED] 

> lH <- sapply(M, function(m) {
+     W <- NULL
+     if (require("qrng")) 
+         W <- t(ghalton(m * N, d = J - 1))
+     st <- system.time(ret <- .... [TRUNCATED] 

> lHf <- sapply(M, function(m) {
+     W <- NULL
+     if (require("qrng")) 
+         W <- t(ghalton(m * N, d = J - 1))
+     st <- system.time(ret < .... [TRUNCATED] 

> layout(matrix(1:2, nrow = 1))

> plot(M, lGB["ll", ], ylim = range(c(lGB["ll", ], lH["ll", 
+     ], lHf["ll", ])), ylab = "Log-likelihood")

> points(M, lH["ll", ], pch = 4)

> points(M, lHf["ll", ], pch = 5)

> plot(M, lGB["user.self", ], ylim = c(0, max(lGB["user.self", 
+     ])), ylab = "Time (in sec)")

> points(M, lH["user.self", ], pch = 4)

> points(M, lHf["user.self", ], pch = 5)

> legend("bottomright", legend = c("pmvnorm", "lmvnorm", 
+     "lmvnorm(fast)"), pch = c(1, 4, 5), bty = "n")

> M <- 500

> if (require("qrng")) {
+     W <- t(ghalton(M * N, d = J - 1))
+ } else {
+     W <- matrix(runif(M * N * (J - 1)), ncol = M)
+ }

> ll <- function(parm, J) {
+     m <- parm[1:J]
+     parm <- parm[-(1:J)]
+     C <- matrix(c(parm), ncol = 1)
+     C <- ltMatrices(C, diag = TRUE, .... [TRUNCATED] 

> prm <- c(mn, unclass(lt))

> ll(prm, J = J)
[1] 860.0128

> lmvnormR(lwr, upr, mean = mn, chol = lt, algorithm = GenzBretz(maxpts = M, 
+     abseps = 0, releps = 0))
[1] -860.0072

> (llprm <- lmvnorm(lwr, upr, mean = mn, chol = lt, 
+     w = W, M = M))
[1] -860.0128

> chk(llprm, sum(lmvnorm(lwr, upr, mean = mn, chol = lt, 
+     w = W, M = M, logLik = FALSE)))

> sc <- function(parm, J) {
+     m <- parm[1:J]
+     parm <- parm[-(1:J)]
+     C <- matrix(c(parm), ncol = 1)
+     C <- ltMatrices(C, diag = TRUE, .... [TRUNCATED] 

> if (require("numDeriv")) print(abs(max(grad(ll, prm, 
+     J = J) - sc(prm, J = J))))
[1] 0.3018445

> llim <- rep(-Inf, J + J * (J + 1)/2)

> llim[J + which(rownames(unclass(lt)) %in% paste(1:J, 
+     1:J, sep = "."))] <- 1e-04

> if (BYROW) {
+     start <- c(rowMeans(Y), chol(Shat)[upper.tri(Shat, diag = TRUE)])
+ } else {
+     start <- c(rowMeans(Y), t(chol(Shat))[lower.tr .... [TRUNCATED] 

> ll(start, J = J)
[1] 858.1291

> op <- optim(start, fn = ll, gr = sc, J = J, method = "L-BFGS-B", 
+     lower = llim, control = list(trace = TRUE))
final  value 857.095419 
converged

> op$value
[1] 857.0954

> ll(prm, J = J)
[1] 860.0128

> (L <- ltMatrices(matrix(op$par[-(1:J)], ncol = 1), 
+     diag = TRUE, byrow = BYROW, trans = TRUE))
, , 1

           1          2         3         4
1  0.6605086  0.0000000 0.0000000 0.0000000
2  0.1819037  0.9604210 0.0000000 0.0000000
3  0.6985604 -0.2216254 1.0412998 0.0000000
4 -0.1362407  1.1914478 0.2660047 0.8597862


> lt
, , 1

          1          2         3         4
1 0.7071068  0.0000000 0.0000000 0.0000000
2 0.2500000  0.9682458 0.0000000 0.0000000
3 0.6123724 -0.1581139 1.0488088 0.0000000
4 0.0000000  1.0954451 0.1651446 0.8790491


> op$par[1:J]
       1        2        3        4 
1.005904 1.967627 2.938949 3.802091 

> mn
[1] 1 2 3 4

> Tcrossprod(lt)
, , 1

          1         2         3       4
1 0.5000000 0.1767767 0.4330127 0.00000
2 0.1767767 1.0000000 0.0000000 1.06066
3 0.4330127 0.0000000 1.5000000 0.00000
4 0.0000000 1.0606602 0.0000000 2.00000


> Tcrossprod(L)
, , 1

            1           2           3           4
1  0.43627157  0.12014893  0.46140512 -0.08998815
2  0.12014893  0.95549737 -0.08578303  1.11950875
3  0.46140512 -0.08578303  1.62140982 -0.08223684
4 -0.08998815  1.11950875 -0.08223684  2.24810008


> Shat
            1           2           3           4
1  0.49613028  0.13904203  0.44517502 -0.08930947
2  0.13904203  1.05349524 -0.07451484  1.12902099
3  0.44517502 -0.07451484  1.54572038 -0.06188290
4 -0.08930947  1.12902099 -0.06188290  2.15211344

 *** Run successfully completed ***
> proc.time()
   user  system elapsed 
 34.027   0.283  34.310 
